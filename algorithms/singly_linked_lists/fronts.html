<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Singly Linked Lists - Fronts Assignment</title>
    <script>
        // class for nodes 
        class Node {
            constructor(value)  {
                this.value = value;
                this.next = null;
            }
        }

        // function to create a blank list.
        class SList {
            constructor() {
                this.head=null;
            }
            addFront(value) {
                console.log ("addFront initiated")
                // Create a new node (note: not assigned to our singly list 'chain' yet)
                const node= new Node(value)
                // take current head (initial node in list), push it to next node; then put this node at the head of the line
                node.next=this.head
                this.head=node   
                console.log(list.display())
                
                // return this to allow method chaining
                return this
            }
            removeFront() {
                console.log ("removeFront initiated")
                const current = this.head
                // if current (this.head) exists (aka if there's a starting pointer in the list, meaning if there's actually data - remove it)
                if (current) {
                    this.head=current.next
                } else {
                    console.log ('not a node, doing nothing')
                }
                console.log(list.display())
                // return this to allow method chaining
                return this
            }
            front() {
                console.log ("front initiated")
                // display the initial value
                const current=this.head
                console.log(list.display())

                return current.value
            }
            contains(value) {
                console.log ("contains initiated")
                // if value found, return true; otherwise, return false
                var current=this.head
                var contains=false
                while (current) {
                    // console.log ("current.value="+current.value)
                    if (current.value==value) {
                        contains=true
                    }
                    current=current.next
                }
                console.log(list.display())

                return contains
            }
            length() {
                console.log ("length initiated")
                // count the length of this singly linked list
                console.log ("length initiated")
                var current=this.head
                var len=0
                while (current) {
                    len++
                    current=current.next
                }
                console.log(list.display())

                return len
            }
            display() {
                console.log ("display initiated")
                var myList=[]
                var current=this.head
                while (current) {
                    myList.push(current.value)
                    current=current.next
                }
                console.log (myList)
                return myList
            }
            min() {
                console.log ("min initiated")
                var current=this.head
                var len=0
                var min=current.value
                while (current) {
                    if (current.value<min) {
                        min=current.value
                    }
                    current=current.next
                }
                return min
            }
            max() {
                console.log ("max initiated")
                var current=this.head
                var max=current.value
                while (current) {
                    if (current.value>max) {
                        max=current.value
                    }
                    current=current.next
                }
                return max
            }
            avg() {
                console.log ("avg initiated")
                var current=this.head
                var len=0
                var total=0
                while (current) {
                    len++
                    total=total+current.value
                    current=current.next
                }
                var avg=total/len
                return avg
            }
            back() {
                console.log ("back initiated")
                // returns the last value in a linked list
                var current=this.head
                while (current) {
                    if (!current.next) {
                        var last=current.value
                    }
                    current=current.next
                }
                return last
            }
            addBack(value) {
                console.log ("addBack initiated")
                var newNode = new Node(value)
                if (!this.head) {
                    this.head = newNode
                } else {
                    var current=this.head
                    while (current) {
                        if (!current.next) {
                            current.next=newNode
                            break
                        }
                        current=current.next
                    }
                }
                console.log(this.display())

                return this
            }
            removeBack() {
                console.log ("removeBack initiated")
                // removes the last node in a s-linked list
                var current=this.head
                while (current) {
                    if (current.next.next == null) {
                        console.log ("last value was "+current.next.value+", new last value is "+current.value)
                        current.next=null
                        break
                    } else {
                        current=current.next
                    }
                }
                console.log(list.display())

                return this
            }
            prependVal(value,before) {
                console.log ("prependVal initiated")
                var current=this.head
                const newNode= new Node(value)

                while (current) {
                    console.log("iterating "+current)
                    if (current.next==null) {
                        console.log("did not find value "+before+" in list")
                        return this
                    }
                    else if (current.next.value == before) {
                        console.log ("match!")
                        newNode.next=current.next
                        current.next=newNode
                        console.log(list.display())
                        return this
                    }
                    current=current.next
                }
                return this
            }
            appendVal(value,after) {
                console.log ("appendVal initiated")
                var current=this.head
                const newNode= new Node(value)

                while (current) {
                    console.log("iterating "+current)
                    
                    if (current.value == after) {
                        console.log ("match!")
                        newNode.next=current.next
                        current.next=newNode
                        console.log(list.display())
                        return this
                    }
                    if (current.next==null) {
                        console.log("did not find value "+after+" in list")
                        return this
                    }

                    current=current.next
                }
                return this
            }
            removeVal(list,value) {
                console.log ("removeVal initiated")
                var current=this.head
                
                // if first matches, update head - then return
                if (current.value == value) {
                    console.log ("matched on list.head")
                    list.head = current.next
                    console.log(list.display())
                    return this
                }

                while (current) {
                    if ( current.next == null) {
                        console.log ("did not find a match, no removeal occurred")
                    } 
                    if ( current.next.value == value ) {
                        console.log("matched (non-head)")
                        current.next = current.next.next
                        console.log(list.display())
                        return this
                    }
                    current=current.next
                }
                console.log(list.display())
                return this
            }
        }
        function secondToLast(list) {
            console.log ("secondToLast initiated")
            var current=list.head
            if ( current.next == null ) {
                console.log ("String length too short")
                return false
            }
            while (current) {
                if (current.next.next == null) {
                    console.log ("Second to last value = "+current.value)
                    return current.value
                }
                current=current.next
            }
        }
        // SList: Delete Given Node
        // Create ListNode method removeSelf() to disconnect (remove) itself from linked lists that include it. Note: the node might be the first in a list (it won’t be the last), and you do NOT have a pointer to the previous node. Also, don’t lose any subsequent nodes pointed to by .next.
        // I do not understand the question... it sounds like the removeVal() method already done above, see lines 224-250.

        function copySList(list) {
            console.log ("copySList initiated")
            var current=list.head
            
            // initialize a new slist, copy first value to new node
            const newList= new SList()
            
            while (current) {
                console.log("Iterating")
                console.log("current.value="+current.value)
                console.log(newList)
                newList.addBack(current.value)
                // if there is no next node, go ahead and return the new list
                if (current.next == null) {
                    return newList
                }
                current=current.next
            }
            console.log ("exiting")
            newlist.display()
            return newList
        }
        
        

        // initialize the singly linked list
        const list=new SList()

        list.addFront(1).addFront(2).addFront(3)
        list.addFront(4)
        list.addFront(5)    // 5,4,3,2,1
        list.removeFront()  // 4,3,2,1 (5 was removed)

        // 6 does not exist, return false
        list.contains(6)

        //4 does exist, return true
        list.contains(4)

        //4 does exist, return true
        list.length()

        // display the list as an actual [list]
        list.display()

        console.log("minimum is "+list.min())
        console.log("maximum is "+list.max())
        console.log("average is "+list.avg())
        console.log("last value is "+list.back())

        list.removeBack()
        list.removeBack()
        list.addBack(11)
        list.addBack(22)
        list.addBack(33)
        list.prependVal(44,3)
        list.appendVal(55,11)
        list.removeVal(list,33)

        secondToLast(list)
        newList=copySList(list)
        newList.addFront(111)
        list.addFront(222)

        list.display()
        newList.display()

    </script>
</head>
<body>
 